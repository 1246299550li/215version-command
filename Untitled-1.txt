每一行相当于i，都有m个物品，那么我们可以根据记录前i个物品的值去转移状态，
但是上述做法是有漏洞的，上述做法，如果当我们取到一个物品是没有奖的时候，而且是没有钱了时候，
并且下一个物品是有奖的，那么按照上述做法，我们依然会去选择这个有奖的，实际上是不行的，
之后我们可以发现，当钱一定是可以用完的并且是刚好有剩下酒的时候，
那么我们有一行的选择一定是刚好选到一个没有奖的，并且这个物品是这一行的终点，
那么我们就考虑重新定义状态，dp[i][j][0|1],对于0,1，分别代表了，
前i行有没有考虑这特殊的一行，然后就是状态转移了，怎么去转移呢，这又是个难点，
我们仔细去想，可以发现，dp[i][j][1]有两种转移的方式，一种是由前一行没有考虑这一个特殊行的转移过来，
一种是由已经考虑过了，按照没有考虑的方式转移，注意，0和1的初始化设置是不一样的，对于1状态，
要初始化为负无穷，为什么呢，因为只有这样才能保证是经过第一种转移过来以后，才能经过第二种转移过来